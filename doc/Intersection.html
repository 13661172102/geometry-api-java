<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>Intersection</title>
		<meta name="author" content="Anne2440" />
		<link rel="stylesheet" href="GeometryDocStyle.css">
	</head>
	<body>
		<div id="content">
			<ul id="menu">
				<li><a href="http://esri.github.io/geometry-api-java/javadoc/com/esri/core/geometry/OperatorIntersection.html">API Reference</a></li>
				<li><a href="https://github.com/Esri/geometry-api-java/wiki/">Wiki Home</a></li>
			</ul>
			<h1 id="topic">Intersection</h1>
			<p>
				The Intersection operator creates the set-theoretic intersection between a geometry, the intersector, and
				one or more other input geometries. The operator returns the intersection of each pair, the intersector and
				each of the input geometries.
			</p>
			<h3>Dimension of output geometries</h3>
			<p>The desired dimension of the output geometries can be specified through the <code>mask</code>
				parameter. The dimension mask only pertains to output. Basically, it is 1 for points/multipoints,
				2 for polylines, 4 for polygons. If we want a combination, add the mask values. For example, if we want to
				get out points and polylines, the mask is 3.  If we want points, polylines and polygons, the mask is 7.
			</p>
			<p>We will get an empty geometry if the intersection for a particular dimension is empty. For example, if the
				mask is 7 but there are no polygon intersections, we will get the point intersections, the polyline
				intersections and an empty polygon.
			</p>
			<p>For the best performance, use the appropriate mask. If we really only want polylines, set the dimension
				mask equal to 2, not 7.  Setting the dimension mask equal to -1 implies that the returned geometry will
				be the lowest dimension of the intersecting pair. For example, if the intersector is a polygon and the
				input geometry is a polygon, the returned geometry will be a polygon. If another input geometry is a polyline,
				the returned geometry will be a polyline. If other dimensions are not important, a dimension mask with
				a value of -1 is the fastest option when intersecting polygons with polygons or polylines.
			</p>
			<h3>Examples</h3>
			<p>
				Let's look at a couple of simple examples. In the following images, the blue geometry is the intersector
				and the green geometries are the input geometries. The intersector is paired with each of the input
				geometries to output the red geometries.
			</p>
			<table>
				<tr>
					<td><img src="Images/Intersection/Intersection1.jpg"></td>
					<td><img src="Images/Intersection/Intersection2.jpg"></td>
					<td><img src="Images/Intersection/Intersection3.jpg"></td>
					<td><img src="Images/Intersection/Intersection4.jpg"></td>
				</tr>
				<tr>
					<td>Intersector and Inputs</td>
					<td>Dimension mask = -1</td>
					<td>Dimension mask = 3</td>
					<td>Dimension mask = 6</td>
				</tr>
			</table>
			<h3>Calling the Intersection operator</h3>
			<p>
				There are two ways to call the Intersection operator as there are two <code>execute</code> methods. One
				of the <code>execute</code> methods doesn't have a <code>mask</code> parameter. By calling this method,
				we are essentially setting the dimension mask equal to -1. Recall that this implies that the returned geometry will
				be the lowest dimension of the intersecting pair.
			</p>
			<p>If we are not using a dimension mask, the call looks like this:</p>
			<div class="codeSnippet">
<pre>
GeometryCursor outputGeoms = OperatorIntersection.local().execute(inputGeoms, intersector, spatialRef, null);
</pre>
			</div>
			<p>If we are using a dimension mask, the call looks like this:</p>
			<div class="codeSnippet">
<pre>
GeometryCursor outputGeoms = OperatorIntersection.local().execute(inputGeoms, intersector, spatialRef, null, mask);
</pre>
			</div>
			<p>where <code>inputGeoms</code> and <code>intersector</code> are of type <code>GeometryCursor</code>.</p>

			<p>Then to retrieve the intersected geometries from the cursor, our code will look something like this:</p>
			<div class="codeSnippet">
<pre>
Geometry geometry = null;

while ((geometry = outputGeoms.next()) != null)
{
   ... do something
}</pre>
			</div>
			<h3>Understanding the output</h3>
			<p>
				The number of output geometries for each input pair depends on the dimension mask. If the dimension mask is
				equal to -1, then there will be one output geometry for each input pair. If the dimension mask is greater than
				0, then for each input pair there will be the same number of output geometries as is specified in the dimension
				mask. Some of the output geometries may be empty.
			</p>
			<p>
				To better understand the output, we will look at the output generated by the application shown below.
				The application creates the geometries we looked at previously and calls intersection with various
				dimension masks. It prints out the JSON format of the output geometries.
			</p>

			<div class="codeSample">
<pre>
package geometryapp;

import com.esri.core.geometry.Geometry;
import com.esri.core.geometry.GeometryCursor;
import com.esri.core.geometry.OperatorExportToJson;
import com.esri.core.geometry.OperatorIntersection;
import com.esri.core.geometry.Polygon;
import com.esri.core.geometry.Polyline;
import com.esri.core.geometry.SimpleGeometryCursor;
import com.esri.core.geometry.SpatialReference;
import java.util.ArrayList;

<span class="codeComment">/*
 * This program creates an intersector polygon, two input polylines and two input
 * polygons. It then calls the Intersection operator with three different
 * dimension masks. Each time the Intersection operator is called, it pairs up
 * the intersector polygon with each of the input geometries. For each pair the
 * dimension of the output is determined by the given dimension mask.
 * -1 => lowest dimension of input pair
 *  3 => output multipoints (1) and polylines (2) (1 + 2 = 3)
 *  6 => polylines (2) and polygons (4) (2 + 4 = 6)
 */</span>

public class IntersectionApp {

  public static void main(String[] args) {

    <span class="codeComment">// Create intersector.</span>
    double coords[][] = {{0,4},{2,10},{8,12},{12,6},{10,2},{4,0}};
    Polygon poly = createPolygon(coords);

    <span class="codeComment">// Create the input polylines.</span>
    ArrayList&lt;Geometry&gt; geomList = createAllInputs();

    <span class="codeComment">// Create a spatial reference object for GCS_WGS_1984.</span>
    SpatialReference sr = SpatialReference.create(4326);

    System.out.println("Intersector");
    printJSONGeometry(sr, poly);

    System.out.println("Input Geometries");
    for (Geometry geom : geomList) {
      printJSONGeometry(sr, geom);
    }

    <span class="codeComment">// Let's try it with different dimension masks.</span>
    int mask[] = {-1, 3, 6};

    for (int i = 0; i &lt; 3; i++) {

      SimpleGeometryCursor inGeoms = new SimpleGeometryCursor(geomList);
      SimpleGeometryCursor intersector = new SimpleGeometryCursor(poly);

      GeometryCursor outGeoms = OperatorIntersection.local().execute(inGeoms, intersector, sr, null, mask[i]);

      System.out.println("*******Dim mask: " + Integer.toString(mask[i]) + "*******");

      <span class="codeComment">// Get the geometries from the cursor and print them in JSON format.</span>
      Geometry geom = null;
      while((geom = outGeoms.next()) != null) {
        printJSONGeometry(sr, geom);
      }
    }
  }

  public static ArrayList&lt;Geometry&gt; createAllInputs() {

    <span class="codeComment">// Create a list of input geometries.</span>
    ArrayList&lt;Geometry&gt; geomList = new ArrayList&lt;Geometry&gt;(4);

    <span class="codeComment">// Polyline 1</span>
    double coords[][] = {{1,15},{3.5,10.5},{6.5,11.5},{18,11.5}};
    geomList.add(createPolyline(coords));

    <span class="codeComment">// Polyline 2</span>
    double coords2[][] = {{-2,10},{1,7}};
    geomList.add(createPolyline(coords2));

    <span class="codeComment">// Polygon 3</span>
    double coords3[][] = {{8,8},{10,10},{14,10},{16,8},{16,4},{14,2},{10,2},{8,4}};
    geomList.add(createPolygon(coords3));

    <span class="codeComment">// Polygon 4</span>
    double coords4[][] = {{1,3},{3,1},{0,0}};
    geomList.add(createPolygon(coords4));

    return geomList;
  }

  public static Polyline createPolyline(double[][] pts) {

    Polyline line = new Polyline();

    line.startPath(pts[0][0], pts[0][1]);

    for (int i = 1; i &lt; pts.length; i++)
      line.lineTo(pts[i][0], pts[i][1]);

    return line;
  }

  public static Polygon createPolygon(double[][] pts) {

    Polygon poly = new Polygon();

    poly.startPath(pts[0][0], pts[0][1]);

    for (int i = 1; i &lt; pts.length; i++)
      poly.lineTo(pts[i][0], pts[i][1]);

    return poly;
  }

  public static void printJSONGeometry(SpatialReference spatialRef, Geometry geometry) {

    System.out.println("Type: " + geometry.getType());

    <span class="codeComment">// Export the geometry to JSON format to print it out.</span>
    String jsonString = OperatorExportToJson.local().execute(spatialRef, geometry);
    System.out.println(jsonString);
    System.out.println();
  }
}
</pre>
		</div>
		<p>Now let's look at the output a bit at a time. </p>
		<p>First, we just print the intersector and the input geometries so we can see the coordinates.</p>
		<div class="image360">
			<img src="Images/Intersection/Intersection5.jpg">
			<div class="desc">Intersector and Inputs</div>
		</div>
		<br/>
		<div class="codeSample">
<pre>
Intersector
Type: Polygon
{"rings":[[[0.0,4.0],[2.0,10.0],[8.0,12.0],[12.0,6.0],[10.0,2.0],[4.0,0.0],[0.0,4.0]]],"spatialReference":{"wkid":4326}}

Input Geometries
Type: Polyline
{"paths":[[[1.0,15.0],[3.5,10.5],[6.5,11.5],[18.0,11.5]]],"spatialReference":{"wkid":4326}}

Type: Polyline
{"paths":[[[-2.0,10.0],[1.0,7.0]]],"spatialReference":{"wkid":4326}}

Type: Polygon
{"rings":[[[8.0,8.0],[10.0,10.0],[14.0,10.0],[16.0,8.0],[16.0,4.0],[14.0,2.0],[10.0,2.0],[8.0,4.0],[8.0,8.0]]],"spatialReference":{"wkid":4326}}

Type: Polygon
{"rings":[[[1.0,3.0],[3.0,1.0],[0.0,0.0],[1.0,3.0]]],"spatialReference":{"wkid":4326}}
</pre>
		</div>
		<p>The first dimension mask is equal to -1. Because the intersector is a polygon, if the input is a polygon, then
			the output will be a polygon. If the input is a polyline, then the output will be a polyline.
			There will be one output for each input geometry.
		</p>
		<p>
			Notice that the second output polyline is empty. This is because the intersection of the intersector polygon and
			Polyline 2 is a point, not a polyline. Similarly, the second output polygon is empty because the
			intersection of the intersector polygon and Polygon 2 is a polyline, not a polygon.
		</p>
		<div class="codeSample">
<pre>
*******Dim mask: -1*******
Type: Polyline
{"paths":[[[3.5,10.5],[6.5,11.5],[8.333333333333334,11.5]]],"spatialReference":{"wkid":4326}}

Type: Polyline
{"paths":[],"spatialReference":{"wkid":4326}}

Type: Polygon
{"rings":[[[10.0,2.0],[8.0,4.0],[8.0,8.0],[9.6,9.6],[12.0,6.0],[10.0,2.0]]],"spatialReference":{"wkid":4326}}

Type: Polygon
{"rings":[],"spatialReference":{"wkid":4326}}
</pre>
		</div>
		<p>Next, we use a dimension mask equal to 3. This signifies that we want to find point/multipoint and polyline
			intersections. Therefore, we will have two output geometries for each input geometry.
		</p>
		<p>Notice that the only multipoint that isn't empty is that which was output as the intersection of the intersector
			and Polyline 2. </p>
		<div class="codeSample">
<pre>
*******Dim mask: 3*******
Type: MultiPoint
{"points":[],"spatialReference":{"wkid":4326}}

Type: Polyline
{"paths":[[[3.5,10.5],[6.5,11.5],[8.333333333333334,11.5]]],"spatialReference":{"wkid":4326}}

Type: MultiPoint
{"points":[[1.0,7.0]],"spatialReference":{"wkid":4326}}

Type: Polyline
{"paths":[],"spatialReference":{"wkid":4326}}

Type: MultiPoint
{"points":[],"spatialReference":{"wkid":4326}}

Type: Polyline
{"paths":[],"spatialReference":{"wkid":4326}}

Type: MultiPoint
{"points":[],"spatialReference":{"wkid":4326}}

Type: Polyline
{"paths":[[[3.0,1.0],[0.9999999999999999,3.0]]],"spatialReference":{"wkid":4326}}
</pre>
		</div>
		<p>Finally, we examine the results when the dimension mask is equal to 6. This time we want intersections that
			are polylines and polygons.
		</p>
		<div class="codeSample">
<pre>
*******Dim mask: 6*******
Type: Polyline
{"paths":[[[3.5,10.5],[6.5,11.5],[8.333333333333334,11.5]]],"spatialReference":{"wkid":4326}}

Type: Polygon
{"rings":[],"spatialReference":{"wkid":4326}}

Type: Polyline
{"paths":[],"spatialReference":{"wkid":4326}}

Type: Polygon
{"rings":[],"spatialReference":{"wkid":4326}}

Type: Polyline
{"paths":[],"spatialReference":{"wkid":4326}}

Type: Polygon
{"rings":[[[10.0,2.0],[8.0,4.0],[8.0,8.0],[9.6,9.6],[12.0,6.0],[10.0,2.0]]],"spatialReference":{"wkid":4326}}

Type: Polyline
{"paths":[[[3.0,1.0],[0.9999999999999999,3.0]]],"spatialReference":{"wkid":4326}}

Type: Polygon
{"rings":[],"spatialReference":{"wkid":4326}}
</pre>
		</div>





		</div>
	</body>
</html>
