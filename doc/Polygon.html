<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>Polygon</title>
		<meta name="author" content="Anne2440" />
		<!-- Date: 2013-07-01 -->
		<style>
			table {margin:auto;width:80%;border: 1px solid black;border-collapse:collapse;}
			th, td {border: 1px solid black;text-align: center;}
			td {font-size:large;font-family:Arial,Verdana,Sans-serif;}
			.codeComment {color:CornflowerBlue;font-style:italic;}
			.codeSnippet {margin-left:4%;font-size:large;}
			.codeInText {font-size:large;}
			p {font-size:large;font-family:Arial,Verdana,Sans-serif;}
		</style>
	</head>
	<body>
		<div><h1 style="float: left;">Polygons</h1>
			<a href="http://esri.github.io/geometry-api-java/javadoc/com/esri/core/geometry/Polygon.html" style="float: right;">API Reference</a><br />
			<a href="https://github.com/Esri/geometry-api-java/wiki" style="float: right;">Wiki Home</a>
			
		</div>
		<div style="clear:both;">
			<p>A polygon is defined by a collection of rings. Each ring is a collection of contiguous line segments such 
				that the start point and the end point are the same. 
			</p>
			<table style="margin-left:auto;margin-right:auto;width:20%">
				<tr>
					<td><img src="Images/Polygon/Ring1.jpg"></td>
				</tr>
				<tr>
					<td>Ring</td>
				</tr>
				
			</table>
			<p>The boundary of a polygon contains one or more outer rings and zero or more inner rings. 
				An outer ring is oriented clockwise while an inner ring is oriented counter-clockwise. 
				Imagine walking clockwise along an outer ring. The area to your immediate right is the 
				interior of the polygon and to your left is the exterior. 
			</p>
			<table style="margin-left:auto;margin-right:auto;width:20%">
				<tr>
					<td><img src="Images/Polygon/Ring2.jpg"></td>
				</tr>
				<tr>
					<td>Outer Ring</td>
				</tr>
			</table>
			<p>Similarly, if you were to walk counter-clockwise along an inner ring, the area to your immediate 
				right is the interior of the polygon and to your left is the exterior. 
			</p>
			<table style="margin-left:auto;margin-right:auto;width:20%">
				<tr>
					<td><img src="Images/Polygon/Ring3.jpg"></td>
				</tr>
				<tr>
					<td>Outer &amp; Inner Ring</td>
				</tr>
			</table>
				<p>So, if a polygon has an 
				inner ring, the inner ring looks like a hole. If the hole contains another outer ring, that 
				outer ring looks like an island. 
			</p>
			<table>
				<tr>
					<td><img src="Images/Polygon/Polygon1.jpg"></td>
					<td><img src="Images/Polygon/Polygon2.jpg"></td>
					<td><img src="Images/Polygon/Polygon3.jpg"></td>
					<td><img src="Images/Polygon/Polygon4.jpg"></td>
				</tr>
				<tr>
					<td>1 outer ring, no inner rings</td>
					<td>4 outer rings, no inner rings</td>
					<td>1 outer ring, 1 inner ring</td>
					<td>2 outer rings, 1 inner ring</td>
				</tr>
			</table>
			<h2>Valid polygons</h2>
			<p>A valid polygon has no overlapping rings, no self-intersections except possibly 
			at vertices, no dangling segments and, in general, an arbitrary point can always be 
			classified unambiguously as either in the exterior, in the interior or on the 
			boundary of the polygon. A valid polygon is said to be <i>simple</i>.
			See the <a href="Simplify.html">Simplify operator</a> for a more detailed specification 
			of simple polygons.
			</p>
			<h3>Examples</h3>
			<p>
				Let's look at some examples of non-simple vs. simple polygons. The green circles are the vertices of the polygon, 
				and the lavender colored area represents the interior of the polygon. 
			</p>
			<table style="width:30%">
				<tr>
					<th colspan="5">Non-simple polygons</th>
				</tr>
				<tr>
					<td><img src="Images/Polygon/NonSimplePolygon1.jpg" width="224" height="200"></td>
					<td><img src="Images/Polygon/NonSimplePolygon2.jpg" width="224" height="200"></td>
					<td><img src="Images/Polygon/NonSimplePolygon3.jpg" width="224" height="200"></td>
					<td><img src="Images/Polygon/NonSimplePolygon5.jpg" width="224" height="200"></td>
					<td><img src="Images/Polygon/NonSimplePolygon4.jpg" width="224" height="200"></td>
				</tr>
				<tr>
					<td>Self-intersection</td>
					<td>Self-intersection</td>
					<td>Dangling segment</td>
					<td>Dangling segment</td>
					<td>Overlapping rings</td>
				</tr>
			</table>
			<br /><br />
			<table style="width:30%">
				<tr>
					<th colspan="5">Simple polygons</th>
				</tr>
				<tr>
					<td><img src="Images/Polygon/SimplePolygon1.jpg" width="224" height="200"></td>
					<td><img src="Images/Polygon/SimplePolygon2.jpg" width="224" height="200"></td>
					<td><img src="Images/Polygon/SimplePolygon3.jpg" width="224" height="200"></td>
					<td><img src="Images/Polygon/SimplePolygon5.jpg" width="224" height="200"></td>
					<td><img src="Images/Polygon/SimplePolygon4.jpg" width="224" height="200"></td>
				</tr>
				<tr>
					<td>No self-intersection</td>
					<td>Self-intersection at vertex</td>
					<td>No dangling segment</td>
					<td>No dangling segment</td>
					<td>No overlapping rings</td>
				</tr>
			</table>
			<p>When drawing a polygon, use the even-odd fill rule. The even-odd fill rule will guarantee that the polygon 
				will draw correctly even if the ring orientation is not as described above for simple polygons. 
			</p>
			<h3>JSON format</h3>
			<p>A polygon can be represented as a JSON string. A polygon in JSON format contains an array of <code>rings</code> 
				and an optional <code>spatialReference</code>. A polygon can also have boolean-valued <code>hasM</code> and <code>hasZ</code> fields. The default value is false 
				for both the <code>hasM</code> and <code>hasZ</code> fields.
			</p>
			<p>Each ring is represented by an array of points. Exterior rings are oriented clockwise, while interior rings 
				are oriented counter-clockwise. The order of the rings is irrelevant. The first point of each ring is always the same as the last point. 
				Each point in a ring is represented as an array of numbers. See the description of 
				<a href="Multipoints.html#JSON">JSON multipoints</a> for details on the interpretation of the point arrays. 
			</p>
			<p>An empty polygon is represented with an empty array for the <code>rings</code> field.</p>
			
			<h4>Syntax</h4>
			<table cellpadding="10" style="width:45%">
				<tr>
					<td style="text-align: left;background-color: LightGray;font-size:medium;">

<pre><code>{
  "hasZ" : true | false,
  "hasM" : true | false,
  "rings": [
             [[&lt;x11&gt;,&lt;y11&gt;,&lt;z11&gt;,&lt;m11&gt;],[&lt;x12&gt;,&lt;y12&gt;,&lt;z12&gt;,&lt;m12&gt;], ... ,[&lt;x11&gt;,&lt;y11&gt;,&lt;z11&gt;,&lt;m11&gt;]],
             ... ,
             [[&lt;xn1&gt;,&lt;yn1&gt;,&lt;zn1&gt;,&lt;mn1&gt;],[&lt;xn2&gt;,&lt;yn2&gt;,&lt;zn2&gt;,&lt;mn2&gt;], ... ,[&lt;xn1&gt;,&lt;yn1&gt;,&lt;zn1&gt;,&lt;mn1&gt;]]
           ],
  "spatialReference" : {"wkid" : &lt;wkid&gt;}
}
</code></pre>
					</td>
				</tr>
			</table>
			<h4>2D polygon</h4>
			<table cellpadding="10" style="width:45%">
				<tr>
					<td style="text-align: left;background-color: LightGray;font-size:medium;">

<pre><code>{
  "rings": [
             [[6453,16815],[10653,16423],[14549,5204],[-7003,6939],[6453,16815]],
             [[914,7992],[3140,11429],[1510,10525],[914,7992]]
           ],
  "spatialReference" : {"wkid" : 54004}
}
</code></pre>
					</td>
				</tr>
			</table>
			<h4>3D polygon with Ms</h4>
			<p>Note that the third point does not have a z-value, and the second ring does not have any m-values.</p>
			<table cellpadding="10" style="width:45%">
				<tr>
					<td style="text-align: left;background-color: LightGray;font-size:medium;">
<pre><code>{
  "hasZ" : true,
  "hasM" : true,
  "rings": [
             [[6453,16815,35,1],[10653,16423,36,2],[14549,5204,null,3],[-7003,6939,37,4],[6453,16815,35,1]],
             [[914,7992,30],[3140,11429,29],[1510,10525,28],[914,7992,30]]
           ],
  "spatialReference" : {"wkid" : 54004}
}
</code></pre>
					</td>
				</tr>
			</table>
			<h4>Empty polygon</h4>
			<table cellpadding="10" style="width:15%">
				<tr>
					<td style="text-align: left;background-color: LightGray;font-size:medium;">

<code>{"rings": []}</code>
					</td>
				</tr>
			</table>
			<h3>Well-known Text (WKT) format</h3>
			<p>A polygon can be represented in WKT format. A polygon in WKT format is an array of rings where a ring is an 
				array of points with the start point equal to the end point. A polygon with exactly one outer ring and zero or more inner rings is designated by the 
				keyword <code>POLYGON</code>. A polygon with one or more outer rings and zero or more inner rings is 
				designated by the keyword <code>MULTIPOLYGON</code>. 
			</p>
			<p>Polygons can have z-values and m-values. To specify that a polygon has z-values, add the keyword <code>Z</code> 
				and for m-values add the keyword <code>M</code>. To specify both z-values and m-values, add the keyword 
				<code>ZM</code>. 
				For example, we might begin our WKT string with <code>MULTIPOLYGON Z</code>, <code>POLYGON M</code> 
				or <code>MULTIPOLYGON ZM</code>. 
				If a polygon has z-values or m-values or both, then a value must be given in the point array for the z-value 
				and/or the m-value. A value of <code>null</code> or <code>"NaN"</code> will not be accepted. See the 
				description of <a href="Multipoints.html#WKT">WKT multipoints</a> for details on the interpretation of the point arrays. 
			</p>
			<p>
				How is an outer ring distinguished from an inner ring in WKT format? Unlike the JSON format for polygons, an 
				outer ring is not distinguished from an inner ring by the orientation of the points. In WKT format, given 
				an array of rings, the outer ring is always first. Every other ring in the array is an inner ring.  
			</p>
			<h4>Syntax</h4>
			<table cellpadding="10" style="width:45%">
				<tr>
					<td style="text-align: left;background-color: LightGray;font-size:medium;">

<pre><code>POLYGON (&lt;outer ring&gt;, &lt;inner ring&gt;, ..., &lt;inner ring&gt;)
</code></pre>
					</td>
				</tr>
				<tr>
					<td style="text-align: left;background-color: LightGray;font-size:medium;">

<pre><code>MULTIPOLYGON ((&lt;outer ring&gt;, &lt;inner ring&gt;, ..., &lt;inner ring&gt;), 
              ..., 
              (&lt;outer ring&gt;, &lt;inner ring&gt;, ..., &lt;inner ring&gt;))
</code></pre>
					</td>
				</tr>
			</table>
			<p>
				where a ring looks like this:<br />
				<code class="codeSnippet">(x1 y1 z1 m1, x2 y2 z2 m2, ..., x1 y1 z1 m1)</code>
			</p>
			<h4>2D polygon with one outer ring and one inner ring</h4>
			<table cellpadding="10" style="width:45%">
				<tr>
					<td style="text-align: left;background-color: LightGray;font-size:medium;">

<code>
<pre>POLYGON ((6 16, -7 6, 14 5, 10 16, 6 16),(0 7, 3 11, 1 10, 0 7))</pre>
</code>
					</td>
				</tr>
			</table>
			<h4>2D polygon with two outer rings and three inner rings</h4>
			<table cellpadding="10" style="width:45%">
				<tr>
					<td style="text-align: left;background-color: LightGray;font-size:medium;">

<code>
<pre>MULTIPOLYGON (((5 1, 7 3, 5 5, 3 3, 5 1),(4 3, 4.5 3, 5 3.5, 4 3),(5 4, 5.5 4, 5 3.5, 5 4)),
              ((1 1, 3 1, 3 -1, 1 -1, 1 1), (1.5 0.5, 2 0.5, 2 -0.5, 1.5 0.5)))</pre>
</code>
					</td>
				</tr>
			</table>
			<h4>3D polygon with two outer rings and one inner ring with m-values</h4>
			<table cellpadding="10" style="width:45%">
				<tr>
					<td style="text-align: left;background-color: LightGray;font-size:medium;">

<code>
<pre>MULTIPOLYGON ZM (((5 1 1 1, 7 3 1.5 2, 5 5 2 3, 3 3 0 0, 5 1 1 1),(4 3 1 1, 4.5 3 1 2, 5 3.5 2 3, 4 3 1 4)),
                 ((1 1 0 1, 3 1 0 2, 3 -1 0 3, 1 -1 0 4, 1 1 0 5)))</pre>
</code>
					</td>
				</tr>
			</table>
			
			
			<h2>Creating a polygon</h2>
			<p>To create a polygon, we can use the <code>Polygon</code> class methods or one of the import operators. </p>
			<p>Each of the code samples below creates a polygon with two outer rings and one inner ring.<br />
				The polygon looks like this:<br />
				<table style="margin-left:auto;margin-right:auto;width:20%">
				<tr>
					<td><img src="Images/Polygon/CreatePolygon.jpg" width="250" height="197"></td>
				</tr>
				<tr>
					<td>Create this polygon</td>
				</tr>
			</table>
				
			</p>
			<h3><code>Polygon</code> class methods</h3>
			<p>When using the <code>Polygon</code> class methods to create a polygon, the order in which the rings are created 
				doesn't matter. What matters is the ring orientation. Remember, clockwise implies an outer ring whereas 
				counter-clockwise implies an inner ring.
			</p>
			<p>To begin each ring, we call the <code>startPath</code> method and then successsive calls to the 
				<code>lineTo</code> method. We don't need to repeat the start point as the end point. 
			</p>
			<table cellpadding="10" style="width:45%">
				<tr>
					<td style="text-align: left;background-color: LightGray;font-size:medium;">

<pre><code>public static Polygon createPolygon1() {

    Polygon poly = new Polygon();

    <span class="codeComment">// clockwise => outer ring</span>
    poly.startPath(0, 0);
    poly.lineTo(-0.5, 0.5);
    poly.lineTo(0.5, 1);
    poly.lineTo(1, 0.5);
    poly.lineTo(0.5, 0);

    <span class="codeComment">// hole</span>
    poly.startPath(0.5, 0.2);
    poly.lineTo(0.6, 0.5);
    poly.lineTo(0.2, 0.9);
    poly.lineTo(-0.2, 0.5);
    poly.lineTo(0.1, 0.2);
    poly.lineTo(0.2, 0.3);
    
    <span class="codeComment">// island</span>
    poly.startPath(0.1, 0.7);
    poly.lineTo(0.3, 0.7);
    poly.lineTo(0.3, 0.4);
    poly.lineTo(0.1, 0.4);
    
    return poly;
}
</code></pre>
					</td>
				</tr>
			</table>
			<h3>Import from JSON</h3>
			<p>As with the <code>Polygon</code> class methods, when using <code>OperatorImportFromJson</code> to create a polygon,
				the order in which the rings are created doesn't matter. What matters is the ring orientation. Unlike the 
				<code>Polygon</code> class methods, the start point of each ring must be repeated to specify the end point.
			</p>
			<p>The code shown below creates the same polygon as before, but notice that the inner ring that forms the hole 
				is given before the outer ring. This was done just to drive home the point that the order of the rings 
				doesn't matter when the polygon is in JSON format.
			</p>
			<table cellpadding="10" style="width:45%">
				<tr>
					<td style="text-align: left;background-color: LightGray;font-size:medium;">

<pre><code>static Polygon createPolygonFromJson() throws JsonParseException, IOException {
    
    String jsonString = "{\"rings\":[[[0.5,0.2],[0.6,0.5],[0.2,0.9],[-0.2,0.5],[0.1,0.2],[0.2,0.3],[0.5,0.2]],
                                     [[0.0,0.0],[-0.5,0.5],[0.0,1.0],[0.5,1.0],[1.0,0.5],[0.5,0.0],[0.0,0.0]],
                                     [[0.1,0.7],[0.3,0.7],[0.3,0.4],[0.1,0.4],[0.1,0.7]]],
                          \"spatialReference\":{\"wkid\":4326}}";
                          
    MapGeometry mapGeom = OperatorImportFromJson.local().execute(Geometry.Type.Polygon, jsonString);
    
    return (Polygon)mapGeom.getGeometry();
}
</code></pre>
					</td>
				</tr>
			</table>
			<h3>Import from WKT</h3>
			<p>Unlike the <code>Polygon</code> class methods and <code>OperatorImportFromJson</code>, when using 
				<code>OperatorImportFromWkt</code> to create a polygon, the order in which the rings are given 
				does matter. Within an array of rings, the outer ring is always first followed by zero or more 
				inner rings. However, the order of the arrays of rings doesn't matter. The start point of each 
				ring must be repeated to specify the end point.
			</p>
			<p>The code shown below creates the same polygon as in the previous examples, but notice that the outer ring 
				that forms the island is given first.
			</p>
			<table cellpadding="10" style="width:45%">
				<tr>
					<td style="text-align: left;background-color: LightGray;font-size:medium;">

<pre><code>static Polygon createPolygonFromWkt() throws JsonParseException, IOException {
    
    String wktString = "MULTIPOLYGON (((0.1 0.7, 0.1 0.4, 0.3 0.4, 0.3 0.7, 0.1 0.7)), 
                                      ((0 0, 0.5 0, 1 0.5, 0.5 1, 0 1, -0.5 0.5, 0 0), 
                                       (0.5 0.2, 0.2 0.3, 0.1 0.2, -0.2 0.5, 0.2 0.9, 0.6 0.5, 0.5 0.2)))";
                                       
    Geometry geom = OperatorImportFromWkt.local().execute(WktImportFlags.wktImportDefaults, Geometry.Type.Polygon, wktString, null);
    
    return (Polygon)geom;
}
</code></pre>
					</td>
				</tr>
			</table>
		</div>
	</body>
</html>

