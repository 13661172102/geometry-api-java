<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>Polygon</title>
		<meta name="author" content="Anne2440" />
		<link rel="stylesheet" href="GeometryDocStyle.css">
	</head>
	<body>
		<h1 id="topic">Polygons</h1>
		<ul id="menu">
			<li><a href="http://esri.github.io/geometry-api-java/javadoc/com/esri/core/geometry/Polygon.html">API Reference</a></li>
			<li><a href="https://github.com/Esri/geometry-api-java/wiki/">Wiki Home</a></li>
		</ul>
		<div id="content">
			<p>A polygon is defined by a collection of rings. Each ring is a collection of contiguous line segments such 
				that the start point and the end point are the same. 
			</p>
			<div class="image240">
				<img src="Images/Polygon/Ring1.jpg">
				<div class="desc">Ring</div>				
			</div>
			<h2 id="boundary">Boundary and Rings</h2>
			<p>The <i>boundary</i> of a polygon is the collection of rings by which the polygon is defined. The boundary 
				contains one or more outer rings and zero or more inner rings. An outer ring is oriented clockwise while 
				an inner ring is oriented counter-clockwise. Imagine walking clockwise along an outer ring. The area to 
				your immediate right is the <i>interior</i> of the polygon and to your left is the <i>exterior</i>. 
				
			</p>
			<div class="image240">
				<img src="Images/Polygon/Ring2.jpg">
				<div class="desc">Outer Ring</div>				
			</div>
			<p>Similarly, if you were to walk counter-clockwise along an inner ring, the area to your immediate 
				right is the interior of the polygon and to your left is the exterior. 
			</p>
			<div class="image240">
				<img src="Images/Polygon/Ring3.jpg">
				<div class="desc">Outer &amp; Inner Ring</div>				
			</div>
			<p>It is important to understand the boundary, interior and exterior of a geometry when using the various 
				operators. The relational operators, for example, rely heavily on these concepts. 
			</p>
			<p>If a polygon has an inner ring, the inner ring looks like a hole. If the hole contains 
				another outer ring, that outer ring looks like an island. 
			</p>
			<table>
				<tr>
					<td><img src="Images/Polygon/Polygon1.jpg"></td>
					<td><img src="Images/Polygon/Polygon2.jpg"></td>
					<td><img src="Images/Polygon/Polygon3.jpg"></td>
					<td><img src="Images/Polygon/Polygon4.jpg"></td>
				</tr>
				<tr>
					<td>1 outer ring, no inner rings</td>
					<td>4 outer rings, no inner rings</td>
					<td>1 outer ring, 1 inner ring</td>
					<td>2 outer rings, 1 inner ring</td>
				</tr>
			</table>
			
			<h2>Valid polygons</h2>
			<p>A valid polygon has no overlapping rings, no self-intersections except possibly 
			at vertices, no dangling segments and, in general, an arbitrary point can always be 
			classified unambiguously as either in the exterior, in the interior or on the 
			boundary of the polygon. A valid polygon is said to be <i>simple</i>.
			See the <a href="Simplify.html">Simplify operator</a> for a more detailed specification 
			of simple polygons.
			</p>
			<h3>Examples</h3>
			<p>
				Let's look at some examples of non-simple vs. simple polygons. The green circles are the vertices of the polygon, 
				and the lavender colored area represents the interior of the polygon. 
			</p>
			<table style="width:30%">
				<tr>
					<th colspan="5">Non-simple polygons</th>
				</tr>
				<tr>
					<td><img src="Images/Polygon/NonSimplePolygon1.jpg" width="224" height="200"></td>
					<td><img src="Images/Polygon/NonSimplePolygon2.jpg" width="224" height="200"></td>
					<td><img src="Images/Polygon/NonSimplePolygon3.jpg" width="224" height="200"></td>
					<td><img src="Images/Polygon/NonSimplePolygon5.jpg" width="224" height="200"></td>
					<td><img src="Images/Polygon/NonSimplePolygon4.jpg" width="224" height="200"></td>
				</tr>
				<tr>
					<td>Self-intersection</td>
					<td>Self-intersection</td>
					<td>Dangling segment</td>
					<td>Dangling segment</td>
					<td>Overlapping rings</td>
				</tr>
			</table>
			<br /><br />
			<table style="width:30%">
				<tr>
					<th colspan="5">Simple polygons</th>
				</tr>
				<tr>
					<td><img src="Images/Polygon/SimplePolygon1.jpg" width="224" height="200"></td>
					<td><img src="Images/Polygon/SimplePolygon2.jpg" width="224" height="200"></td>
					<td><img src="Images/Polygon/SimplePolygon3.jpg" width="224" height="200"></td>
					<td><img src="Images/Polygon/SimplePolygon5.jpg" width="224" height="200"></td>
					<td><img src="Images/Polygon/SimplePolygon4.jpg" width="224" height="200"></td>
				</tr>
				<tr>
					<td>No self-intersection</td>
					<td>Self-intersection at vertex</td>
					<td>No dangling segment</td>
					<td>No dangling segment</td>
					<td>No overlapping rings</td>
				</tr>
			</table>
			<p>When drawing a polygon, use the even-odd fill rule. The even-odd fill rule will guarantee that the polygon 
				will draw correctly even if the ring orientation is not as described above for simple polygons. 
			</p>
			<h3 id="JSON">JSON format</h3>
			<p>A polygon can be represented as a JSON string. A polygon in JSON format contains an array of <code>rings</code> 
				and an optional <code>spatialReference</code>. A polygon can also have boolean-valued <code>hasM</code> and <code>hasZ</code> fields. The default value is false 
				for both the <code>hasM</code> and <code>hasZ</code> fields.
			</p>
			<p>Each ring is represented by an array of points. Exterior rings are oriented clockwise, while interior rings 
				are oriented counter-clockwise. The order of the rings is irrelevant. The first point of each ring is always the same as the last point. 
				Each point in a ring is represented as an array of numbers. See the description of 
				<a href="Multipoint.html#JSON">JSON multipoints</a> for details on the interpretation of the point arrays. 
			</p>
			<p>An empty polygon is represented with an empty array for the <code>rings</code> field.</p>
			
			<h4>Syntax</h4>
			<div class="codeSample">
<pre>{
  "hasZ" : true | false,
  "hasM" : true | false,
  "rings": [
             [[&lt;x<sub>11</sub>&gt;,&lt;y<sub>11</sub>&gt;,&lt;z<sub>11</sub>&gt;,&lt;m<sub>11</sub>&gt;],[&lt;x<sub>12</sub>&gt;,&lt;y<sub>12</sub>&gt;,&lt;z<sub>12</sub>&gt;,&lt;m<sub>12</sub>&gt;], ... ,[&lt;x<sub>1j</sub>&gt;,&lt;y<sub>1j</sub>&gt;,&lt;z<sub>1j</sub>&gt;,&lt;m<sub>1j</sub>&gt;]],
             ... ,
             [[&lt;x<sub>n1</sub>&gt;,&lt;y<sub>n1</sub>&gt;,&lt;z<sub>n1</sub>&gt;,&lt;m<sub>n1</sub>&gt;],[&lt;x<sub>n2</sub>&gt;,&lt;y<sub>n2</sub>&gt;,&lt;z<sub>n2</sub>&gt;,&lt;m<sub>n2</sub>&gt;], ... ,[&lt;x<sub>nk</sub>&gt;,&lt;y<sub>nk</sub>&gt;,&lt;z<sub>nk</sub>&gt;,&lt;m<sub>nk</sub>&gt;]]
           ],
  "spatialReference" : {"wkid" : &lt;wkid&gt;}
}</pre>
			</div>
			<h4>2D Polygon</h4>
			<div class="codeSample">
<pre>{
  "rings": [
             [[6453,16815],[10653,16423],[14549,5204],[-7003,6939],[6453,16815]],
             [[914,7992],[3140,11429],[1510,10525],[914,7992]]
           ],
  "spatialReference" : {"wkid" : 54004}
}
</pre>
			</div>
			<h4>3D Polygon with Ms</h4>
			<p>Note that the third point does not have a z-value, and the second ring does not have any m-values.</p>
			<div class="codeSample">
<pre>{
  "hasZ" : true,
  "hasM" : true,
  "rings": [
             [[6453,16815,35,1],[10653,16423,36,2],[14549,5204,null,3],[-7003,6939,37,4],[6453,16815,35,1]],
             [[914,7992,30],[3140,11429,29],[1510,10525,28],[914,7992,30]]
           ],
  "spatialReference" : {"wkid" : 54004}
}
</pre>
			</div>
			<h4>Empty Polygon</h4>
			<div class="codeSample">
				<pre class="emptyGeom">{"rings": []}</pre>
			</div>
			
			<h3 id="GeoJSON">GeoJSON format</h3>
			<p>A polygon can be represented in GeoJSON format. A polygon in GeoJSON format is an array of rings, 
				with field name <code>coordinates</code>, where a ring is an array of points with the start point 
				equal to the end point. A polygon may have an optional <code>crs</code> field representing a spatial 
				reference. If no spatial reference is given, the default value of GCS_WGS_1984 is used. At this time, 
				z-values and m-values are not supported. 
			</p>
			<p>A polygon with exactly one outer ring and zero or more inner rings is designated 
				by a <code>type</code> field whose value is <code>Polygon</code>. A polygon with one or more outer 
				rings and zero or more inner rings is designated by a <code>type</code> field whose value is 
				<code>MultiPolygon</code>. 
			</p>
			<p>How is an outer ring distinguished from an inner ring in GeoJSON format? Unlike the JSON format for polygons, an 
				outer ring is not distinguished from an inner ring by the orientation of the points. In GeoJSON format, given 
				an array of rings, the outer ring is always first. Every other ring in the array is an inner ring.   
			</p>
			<p>An empty polygon is represented with an empty array for the <code>coordinates</code> field.</p>
			
			<h4>Syntax</h4>
			<div class="codeSample">
<pre>{
  "type" : "Polygon",
  "coordinates": [&lt;outer ring&gt;, &lt;inner ring&gt;, ..., &lt;inner ring&gt;],
  "crs" : "EPSG:&lt;wkid&gt";
}
</pre>

<pre>{
  "type" : "MultiPolygon",
  "coordinates": [
                   [&lt;outer ring&gt;, &lt;inner ring&gt;, ..., &lt;inner ring&gt;],
                   ...,
                   [&lt;outer ring&gt;, &lt;inner ring&gt;, ..., &lt;inner ring&gt;]
                 ],
  "crs" : "EPSG:&lt;wkid&gt";
}
</pre>
			</div>
			<p>
				where a ring looks like this:<br />
				<code class="codeSnippet">[[&lt;x<sub>1</sub>&gt;, &lt;y<sub>1</sub>&gt;], [&lt;x<sub>2</sub>&gt;, &lt;y<sub>2</sub>&gt;], ..., [&lt;x<sub>1</sub>&gt;, &lt;y<sub>1</sub>&gt;]]</code>
			</p>
			<h4>2D Polygon</h4>
			<div class="codeSample">
<pre>{
  "type" : "Polygon",
  "coordinates": 
           [
             [[6453,16815],[10653,16423],[14549,5204],[-7003,6939],[6453,16815]],
             [[914,7992],[3140,11429],[1510,10525],[914,7992]]
           ],
  "crs" : "EPSG:54004"
}
</pre>
		</div>
			<h4>2D MultiPolygon</h4>
			<div class="codeSample">
<pre>{
  "type" : "MultiPolygon",
  "coordinates": 
         [
           [
             [[0.6,0.4],[0.6,1],[1,1.4],[1.4,1],[1.4,0.4],[0.6,0.4]],
             [[0.8,0.6],[1.2,0.8],[1,1],[0.8,1],[0.8,0.6]]
           ],
           [
             [[1.8,1],[1.8,2],[3,2],[3,1],[1.8,1]],
             [[2.09,1.33],[2.2,1.6],[2,1.8],[1.89,1.41],[2.09,1.33]],
             [[2.69,1.21],[2.8,1.4],[2.46,1.4],[2.69,1.21]]
           ]
         ],
  "crs" : "EPSG:4326"
}
</pre>
		</div>
			<h4>Empty Polygon</h4>
			<div class="codeSample">
				<pre class="emptyGeoJson">{"type" : "Polygon", "coordinates": []}</pre>
			</div>
			<h3 id="WKT">Well-known Text (WKT) format</h3>
			<p>A polygon can be represented in WKT format. A polygon in WKT format is an array of rings where a ring is an 
				array of points with the start point equal to the end point. A polygon with exactly one outer ring and zero or more inner rings is designated by the 
				keyword <code>POLYGON</code>. A polygon with one or more outer rings and zero or more inner rings is 
				designated by the keyword <code>MULTIPOLYGON</code>. 
			</p>
			<p>Polygons can have z-values and m-values. To specify that a polygon has z-values, add the keyword <code>Z</code> 
				and for m-values add the keyword <code>M</code>. To specify both z-values and m-values, add the keyword 
				<code>ZM</code>. 
				For example, we might begin our WKT string with <code>MULTIPOLYGON Z</code>, <code>POLYGON M</code> 
				or <code>MULTIPOLYGON ZM</code>. 
				If a polygon has z-values or m-values or both, then a value must be given in the point array for the z-value 
				and/or the m-value. A value of <code>null</code> or <code>"NaN"</code> will not be accepted. See the 
				description of <a href="Multipoints.html#WKT">WKT multipoints</a> for details on the interpretation of the point arrays. 
			</p>
			<p>
				How is an outer ring distinguished from an inner ring in WKT format? Unlike the JSON format for polygons, an 
				outer ring is not distinguished from an inner ring by the orientation of the points. In WKT format, given 
				an array of rings, the outer ring is always first. Every other ring in the array is an inner ring.  
			</p>
			<h4>Syntax</h4>
			<div class="codeSample">
<pre>POLYGON (&lt;outer ring&gt;, &lt;inner ring&gt;, ..., &lt;inner ring&gt;)
</pre>
<pre>MULTIPOLYGON ((&lt;outer ring&gt;, &lt;inner ring&gt;, ..., &lt;inner ring&gt;), 
              ..., 
              (&lt;outer ring&gt;, &lt;inner ring&gt;, ..., &lt;inner ring&gt;))
</pre>
			</div>
			<p>
				where a ring looks like this:<br />
				<code class="codeSnippet">(&lt;x<sub>1</sub>&gt; &lt;y<sub>1</sub>&gt; &lt; z<sub>1</sub>&gt; &lt;m<sub>1</sub>&gt;, &lt;x<sub>2</sub>&gt; &lt;y<sub>2</sub>&gt; &lt; z<sub>2</sub>&gt; &lt;m<sub>2</sub>&gt;, ..., &lt;x<sub>1</sub>&gt; &lt;y<sub>1</sub>&gt; &lt; z<sub>1</sub>&gt; &lt;m<sub>1</sub>&gt;)</code>
			</p>
			<h4>2D polygon with one outer ring and one inner ring</h4>
			<div class="codeSample">
<pre>POLYGON ((6 16, -7 6, 14 5, 10 16, 6 16),(0 7, 3 11, 1 10, 0 7))</pre>
			</div>
			<h4>2D polygon with two outer rings and three inner rings</h4>
			<div class="codeSample">
<pre>MULTIPOLYGON (((5 1, 7 3, 5 5, 3 3, 5 1),(4 3, 4.5 3, 5 3.5, 4 3),(5 4, 5.5 4, 5 3.5, 5 4)),
              ((1 1, 3 1, 3 -1, 1 -1, 1 1), (1.5 0.5, 2 0.5, 2 -0.5, 1.5 0.5)))</pre>
			</div>
			<h4>3D polygon with two outer rings and one inner ring with m-values</h4>
			<div class="codeSample">
<pre>MULTIPOLYGON ZM (((5 1 1 1, 7 3 1.5 2, 5 5 2 3, 3 3 0 0, 5 1 1 1),(4 3 1 1, 4.5 3 1 2, 5 3.5 2 3, 4 3 1 4)),
                 ((1 1 0 1, 3 1 0 2, 3 -1 0 3, 1 -1 0 4, 1 1 0 5)))</pre>
		</div>
			<h2>Creating a polygon</h2>
			<p>To create a polygon, we can use the <code>Polygon</code> class methods or one of the import operators. </p>
			<p>Each of the code samples below creates a polygon with two outer rings and one inner ring.<br />
				The polygon looks like this:<br />
				<table style="margin-left:auto;margin-right:auto;width:20%">
				<tr>
					<td><img src="Images/Polygon/CreatePolygon.jpg" width="250" height="197"></td>
				</tr>
				<tr>
					<td>Create this polygon</td>
				</tr>
			</table>
				
			</p>
			<h3><code>Polygon</code> class methods</h3>
			<p>When using the <code>Polygon</code> class methods to create a polygon, the order in which the rings are created 
				doesn't matter. What matters is the ring orientation. Remember, clockwise implies an outer ring whereas 
				counter-clockwise implies an inner ring.
			</p>
			<p>To begin each ring, we call the <code>startPath</code> method and then successsive calls to the 
				<code>lineTo</code> method. We don't need to repeat the start point as the end point. 
			</p>
			<div class="codeSample">
<pre class="classMethod">public static Polygon createPolygon1() {

    Polygon poly = new Polygon();

    <span class="codeComment">// clockwise => outer ring</span>
    poly.startPath(0, 0);
    poly.lineTo(-0.5, 0.5);
    poly.lineTo(0.5, 1);
    poly.lineTo(1, 0.5);
    poly.lineTo(0.5, 0);

    <span class="codeComment">// hole</span>
    poly.startPath(0.5, 0.2);
    poly.lineTo(0.6, 0.5);
    poly.lineTo(0.2, 0.9);
    poly.lineTo(-0.2, 0.5);
    poly.lineTo(0.1, 0.2);
    poly.lineTo(0.2, 0.3);
    
    <span class="codeComment">// island</span>
    poly.startPath(0.1, 0.7);
    poly.lineTo(0.3, 0.7);
    poly.lineTo(0.3, 0.4);
    poly.lineTo(0.1, 0.4);
    
    return poly;
}
</pre>
			</div>
			<h3>Import from JSON</h3>
			<p>As with the <code>Polygon</code> class methods, when using <code>OperatorImportFromJson</code> 
				to create a polygon the order in which the rings are created doesn't matter. What matters is the 
				ring orientation. Unlike the <code>Polygon</code> class methods, the start point of each ring must 
				be repeated to specify the end point.
			</p>
			<p>The code shown below creates the same polygon as before, but notice that the inner ring that forms the hole 
				is given before the outer ring. This was done just to drive home the point that the order of the rings 
				doesn't matter when the polygon is in JSON format.
			</p>
			<div class="codeSample">
<pre class="import">static Polygon createPolygonFromJson() throws JsonParseException, IOException {
    
    String jsonString = "{\"rings\":[[[0.5,0.2],[0.6,0.5],[0.2,0.9],[-0.2,0.5],[0.1,0.2],[0.2,0.3],[0.5,0.2]],"
                      + "[[0.0,0.0],[-0.5,0.5],[0.0,1.0],[0.5,1.0],[1.0,0.5],[0.5,0.0],[0.0,0.0]],"
                      + "[[0.1,0.7],[0.3,0.7],[0.3,0.4],[0.1,0.4],[0.1,0.7]]],"            
                      + " \"spatialReference\":{\"wkid\":4326}}";              
                          
    MapGeometry mapGeom = OperatorImportFromJson.local().execute(Geometry.Type.Polygon, jsonString);
    
    return (Polygon)mapGeom.getGeometry();
}
</pre>
			</div>
			<h3>Import from GeoJSON</h3>
			<p>Unlike the <code>Polygon</code> class methods and <code>OperatorImportFromJson</code>, when using 
				<code>OperatorImportFromGeoJson</code> to create a polygon the order in which the rings are given 
				does matter. Within an array of rings, the outer ring is always first followed by zero or more 
				inner rings. However, the order of the arrays of rings doesn't matter. The start point of each 
				ring must be repeated to specify the end point.
			</p>
			<p>The code shown below creates the same polygon as in the previous examples. 
			</p>
			<div class="codeSample">
<pre class="import">static Polygon createPolygonFromGeoJson() throws JsonParseException, IOException {
    
    String geoJsonString = "{\"type\":\"MultiPolygon\","
                         + "\"coordinates\":[[[[0.0,0.0],[-0.5,0.5],[0.0,1.0],[0.5,1.0],[1.0,0.5],[0.5,0.0],[0.0,0.0]],"
                         + "[[0.5,0.2],[0.6,0.5],[0.2,0.9],[-0.2,0.5],[0.1,0.2],[0.2,0.3],[0.5,0.2]]],"
                         + "[[[0.1,0.7],[0.3,0.7],[0.3,0.4],[0.1,0.4],[0.1,0.7]]]],"
                         + "\"crs\":\"EPSG:4326\"}";
                          
    MapGeometry mapGeom = OperatorImportFromGeoJson.local().execute(GeoJsonImportFlags.geoJsonImportDefaults, Geometry.Type.Polygon, geoJsonString, null);
    
    return (Polygon)mapGeom.getGeometry();
}
</pre>
			</div>
			<h3>Import from WKT</h3>
			<p>As with <code>OperatorImportFromGeoJson</code>, when using <code>OperatorImportFromWkt</code> 
				to create a polygon the order in which the rings are given does matter. Within an array of rings, 
				the outer ring is always first followed by zero or more inner rings. However, the order of the arrays 
				of rings doesn't matter. The start point of each ring must be repeated to specify the end point.
			</p>
			<p>The code shown below creates the same polygon as in the previous examples, but notice that the outer ring 
				that forms the island is given first. This was done for illustrative purposes. It could have been given last, 
				which probably would be more understandable to the reader. 
			</p>
			<div class="codeSample">
<pre class="import">static Polygon createPolygonFromWKT() throws JsonParseException, IOException {
    
    String wktString = "MULTIPOLYGON (((0.1 0.7, 0.1 0.4, 0.3 0.4, 0.3 0.7, 0.1 0.7)),"
                     + "((0 0, 0.5 0, 1 0.5, 0.5 1, 0 1, -0.5 0.5, 0 0),"
                     + "(0.5 0.2, 0.2 0.3, 0.1 0.2, -0.2 0.5, 0.2 0.9, 0.6 0.5, 0.5 0.2)))";
                                       
    Geometry geom = OperatorImportFromWkt.local().execute(WktImportFlags.wktImportDefaults, Geometry.Type.Polygon, wktString, null);
    
    return (Polygon)geom;
}
</pre>
			</div>
			<br /><br />
		</div>
	</body>
</html>

